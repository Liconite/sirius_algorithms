# Cложность алгоритма: O(n)
# Пояснение: jewels можно представить, как "алфавит" уникальных значений, а stones как "слово".
# Задача сводится к подсчёту количества уникальных алфавита в слове

# Решение 1
def numJewelsInStones1(jewels, stones):
    k = 0   # счетчик уникальных значений
    for i in stones:    # перебираем "буквы" из слова
        if i in jewels:    # проверяем наличие буквы в алфавите
            k += 1
    return k


# Решение 2
def numJewelsInStones2(jewels, stones):
    k = 0
    for i in jewels:    # перебираем "буквы" из алфавита
        if i in stones:    # проверяем наличие буквы в слове
            k += stones.count(i) # считаем кол-во взятой буквы и прибавляем в счётчик
    return k

# Второе решение оказалось чуть быстрее, чем первое
# в тест-кейсах на LeetCode